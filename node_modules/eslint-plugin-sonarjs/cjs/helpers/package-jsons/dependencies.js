"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.dependenciesCache = void 0;
exports.getDependencies = getDependencies;
exports.getDependenciesSanitizePaths = getDependenciesSanitizePaths;
exports.getReactVersion = getReactVersion;
exports.parseReactVersion = parseReactVersion;
const cache_js_1 = require("../cache.js");
const node_fs_1 = __importDefault(require("node:fs"));
const semver_1 = require("semver");
const files_js_1 = require("../files.js");
const parse_js_1 = require("./parse.js");
const closest_js_1 = require("./closest.js");
const all_in_parent_dirs_js_1 = require("./all-in-parent-dirs.js");
/**
 * Cache for the available dependencies by dirname. Exported for tests
 */
exports.dependenciesCache = new cache_js_1.ComputedCache((dir, topDir) => {
    const closestPackageJSONDirName = (0, closest_js_1.getClosestPackageJSONDir)(dir, topDir);
    const result = new Set();
    if (closestPackageJSONDirName) {
        for (const manifest of (0, all_in_parent_dirs_js_1.getManifests)(closestPackageJSONDirName, topDir, node_fs_1.default)) {
            const manifestDependencies = (0, parse_js_1.getDependenciesFromPackageJson)(manifest);
            for (const dependency of manifestDependencies) {
                result.add(dependency.name);
            }
        }
    }
    return result;
});
/**
 * Retrieve the dependencies of all the package.json files available for the given file.
 *
 * @param dir dirname of the context.filename
 * @param topDir working dir, will search up to that root
 * @returns Set with the dependency names
 */
function getDependencies(dir, topDir) {
    const closestPackageJSONDirName = (0, closest_js_1.getClosestPackageJSONDir)(dir, topDir);
    if (closestPackageJSONDirName) {
        return exports.dependenciesCache.get(closestPackageJSONDirName, topDir);
    }
    return new Set();
}
function getDependenciesSanitizePaths(context) {
    return getDependencies((0, files_js_1.dirnamePath)((0, files_js_1.normalizeToAbsolutePath)(context.filename)), (0, files_js_1.normalizeToAbsolutePath)(context.cwd));
}
/**
 * Gets the React version from the closest package.json.
 *
 * @param context ESLint rule context
 * @returns React version string (coerced from range) or null if not found
 */
function getReactVersion(context) {
    const dir = (0, files_js_1.dirnamePath)((0, files_js_1.normalizeToAbsolutePath)(context.filename));
    for (const packageJson of (0, all_in_parent_dirs_js_1.getManifests)(dir, (0, files_js_1.normalizeToAbsolutePath)(context.cwd), node_fs_1.default)) {
        const reactVersion = packageJson.dependencies?.react ?? packageJson.devDependencies?.react;
        if (reactVersion) {
            const parsed = parseReactVersion(reactVersion);
            if (parsed) {
                return parsed;
            }
            // Continue searching in parent package.json files if parsing fails
        }
    }
    return null;
}
/**
 * Parses a React version string and returns a valid semver version.
 * Exported for testing purposes.
 *
 * @param reactVersion Version string from package.json (e.g., "^18.0.0", "19.0", "catalog:frontend")
 * @returns Valid semver version string or null if parsing fails
 */
function parseReactVersion(reactVersion) {
    try {
        // Coerce version ranges (e.g., "^18.0.0") to valid semver versions
        return (0, semver_1.minVersion)(reactVersion)?.version ?? null;
    }
    catch {
        // Handle non-semver strings like pnpm catalog references (e.g., "catalog:frontend")
        return null;
    }
}
